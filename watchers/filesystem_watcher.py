"""
File System Watcher - Monitors a drop folder for new files

This watcher monitors a designated "drop folder" for new files.
When a file is created, it copies it to the Needs_Action folder
and creates accompanying metadata.

Usage:
    python filesystem_watcher.py /path/to/vault /path/to/drop_folder
"""

import sys
import shutil
import time
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileCreatedEvent

# Handle both package import and direct script execution
try:
    from .base_watcher import BaseWatcher
except ImportError:
    from base_watcher import BaseWatcher


class DropFolderHandler(FileSystemEventHandler):
    """Handles file system events for the drop folder."""
    
    def __init__(self, vault_path: Path, watcher_instance):
        self.vault_path = vault_path
        self.needs_action = vault_path / 'Needs_Action'
        self.watcher = watcher_instance
        self.logger = watcher_instance.logger
    
    def on_created(self, event):
        """Handle file creation events."""
        if event.is_directory:
            return
        
        source = Path(event.src_path)
        self.logger.info(f'New file detected: {source.name}')
        
        # Copy file to Needs_Action
        dest = self.needs_action / f'FILE_{source.name}'
        
        try:
            shutil.copy2(source, dest)
            self.logger.info(f'Copied to: {dest}')
            
            # Create metadata file
            self.create_metadata(source, dest)
        except Exception as e:
            self.logger.error(f'Error processing file: {e}')
    
    def create_metadata(self, source: Path, dest: Path):
        """Create a metadata .md file for the dropped file."""
        meta_path = dest.with_suffix('.md')
        
        content = f'''---
type: file_drop
original_name: {source.name}
size: {source.stat().st_size}
created: {self.watcher.get_timestamp()}
status: pending
---

# File Drop for Processing

A new file has been dropped for processing.

## File Details
- **Original Name:** {source.name}
- **Size:** {self._format_size(source.stat().st_size)}
- **Copied To:** `{dest.name}`
- **Detected At:** {self.watcher.get_timestamp()}

## Suggested Actions
- [ ] Review file contents
- [ ] Determine required action
- [ ] Process and move to /Done when complete

## Notes
*Add any notes about processing this file below.*

---
*Generated by File System Watcher v0.1*
'''
        meta_path.write_text(content)
        self.logger.info(f'Created metadata: {meta_path.name}')
    
    def _format_size(self, size: int) -> str:
        """Format file size in human-readable format."""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024:
                return f'{size:.1f} {unit}'
            size /= 1024
        return f'{size:.1f} TB'


class FilesystemWatcher(BaseWatcher):
    """
    Watcher that monitors a drop folder for new files.
    
    Uses watchdog library for efficient file system monitoring.
    """
    
    def __init__(self, vault_path: str, drop_folder: str = None, check_interval: int = 5):
        """
        Initialize the filesystem watcher.
        
        Args:
            vault_path: Path to the Obsidian vault root
            drop_folder: Path to the drop folder (default: vault/Inbox/Drop)
            check_interval: Polling interval in seconds (default: 5)
        """
        super().__init__(vault_path, check_interval)
        
        # Set up drop folder
        if drop_folder:
            self.drop_folder = Path(drop_folder)
        else:
            self.drop_folder = self.vault_path / 'Inbox' / 'Drop'
        
        self.drop_folder.mkdir(parents=True, exist_ok=True)
        self.logger.info(f'Drop folder: {self.drop_folder}')
    
    def check_for_updates(self) -> list:
        """
        This method is not used in the traditional sense for filesystem watcher.
        The watchdog observer handles event-driven detection.
        
        Returns:
            Empty list (actual processing is event-driven)
        """
        return []
    
    def create_action_file(self, item) -> Path:
        """
        Not used for filesystem watcher - files are processed via events.
        
        Args:
            item: Not used
            
        Returns:
            None
        """
        pass
    
    def run(self):
        """
        Run the filesystem watcher with event-driven monitoring.
        """
        self.logger.info(f'Starting FilesystemWatcher')
        self.logger.info(f'Drop folder: {self.drop_folder}')
        
        # Set up the observer
        event_handler = DropFolderHandler(self.vault_path, self)
        observer = Observer()
        observer.schedule(event_handler, str(self.drop_folder), recursive=False)
        observer.start()
        
        self.logger.info(f'Watching for new files in: {self.drop_folder}')
        self.logger.info('Press Ctrl+C to stop')
        
        try:
            while True:
                time.sleep(self.check_interval)
        except KeyboardInterrupt:
            self.logger.info('Stopping watcher...')
            observer.stop()
        
        observer.join()
        self.logger.info('Watcher stopped')


def main():
    """Main entry point for the filesystem watcher."""
    if len(sys.argv) < 2:
        print('Usage: python filesystem_watcher.py <vault_path> [drop_folder]')
        print('')
        print('Arguments:')
        print('  vault_path   - Path to your Obsidian vault')
        print('  drop_folder  - Optional: Path to drop folder (default: vault/Inbox/Drop)')
        print('')
        print('Example:')
        print('  python filesystem_watcher.py "C:/Users/Name/AI_Employee_Vault"')
        sys.exit(1)
    
    vault_path = sys.argv[1]
    drop_folder = sys.argv[2] if len(sys.argv) > 2 else None
    
    # Validate vault path
    if not Path(vault_path).exists():
        print(f'Error: Vault path does not exist: {vault_path}')
        sys.exit(1)
    
    watcher = FilesystemWatcher(vault_path, drop_folder)
    watcher.run()


if __name__ == '__main__':
    main()
